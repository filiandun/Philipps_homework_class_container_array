#pragma once

/*
—оздать шаблонный класс-контейнер Array, который представл€ет собой массив, позвол€ющий хранить объекты
заданного типа.  ласс должен быть реализован с помощью двусв€зного списка.  ласс должен реализовывать следующие функции:

a. GetSize Ч получение размера массива (количество элементов, под которые выделена пам€ть).
b. SetSize(int size, int grow = 1) Ч установка размера массива (если параметр size больше предыдущего размера массива, то выдел€етс€ дополнительный блок пам€ти,
	если нет, то "лишние" элементы тер€ютс€ и пам€ть освобождаетс€); параметр grow определ€ет дл€ какого количества элементов необходимо выделить пам€ть, 
	если количество элементов превосходит текущий размер массива. Ќапример, SetSize(5, 5); означает, 
	что при добавлении 6-го элемента размер массива становитс€ равным 10, при добавлении 11-го Ч 15 и т. д.
c. GetUpperBound Ч получение последнего допустимого индекса в массиве. Ќапример, если при размере массива 10, вы добавл€ете в него 4 элемента, то функци€ вернет 3.
d. IsEmpty Ч массив пуст?
e. FreeExtra Ч удалить "лишнюю" пам€ть (выше последнего допустимого индекса);
f. RemoveAll Ч удалить все;
g. GetAt Ч получение определенного элемента (по индексу);
h. SetAt Ч установка нового значени€ дл€ определенного элемента (индекс элемента должен быть меньше текущего размера массива);
i. operator [] Ч дл€ реализации двух предыдущих функций;
j. Add Ч добавление элемента в массив (при необходимости массив увеличиваетс€ на значение grow функции SetSize);
k. Append Ч "сложение" двух массивов;
l. operator =;
m. GetData Ч получени€ адреса массива с данными;
n. InsertAt Ч вставка элемента(-ов) в заданную позицию;
o. RemoveAt Ч удаление элемента(-ов) с заданной позиции.
*/


template<typename T>
class Node
{
public:
	Node();
	~Node();

private:
	Node* previous_node;
	Node* next_node;

	T* data;
};

template<typename T>
class Array
{
public:
	Array();
	Array(const Array& a);

	~Array();

private:
	Node* begin_node;
	Node* end_node;

	size_t size;

public:
	size_t get_size();
	size_t set_size(size_t size);
	size_t get_upper_bound();

	bool is_empty();
	void free_extra();
	void remove_all();

	T get_at(size_t index);
	void set_at(size_t index);

	Array operator[](const Array& a);
	
	void add();
	void append();

	Array operator=(const Array& a);

	Array* get_data();
};

